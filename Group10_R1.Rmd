---
title: "R1 project"
subtitle: "Group 10"
author: 
- Christopher Comora
- Nataliya Peshekhodko 
- Zhuoning Liu
date: '`r format(Sys.Date(), "%Y-%B-%d")`'

output:
  pdf_document: default
  html_document: default
---

```{r, echo = FALSE}
library(knitr)
set.seed(10)
```

## 1. General Procedure
```{r}
n=10
lambda = 1
B = 1000
alpha = 0.05
```
1.a Generate a random sample of size `r n` with parameter $\lambda$=`r lambda`. 
```{r}
data = rpois (n, lambda)
```

1. b Create and save a 95% CI for the mean of the population using the approximate
confidence interval 1.

```{r}
lambda_hat = mean (data)

lower_bound_ci1 = lambda_hat - qnorm(1-alpha/2)*sqrt(var(data)/length(data))
upper_bound_ci1 = lambda_hat + qnorm(1-alpha/2)*sqrt(var(data)/length(data))
c(lower_bound_ci1, upper_bound_ci1)
```

1. c Create and save a 95% CI for the mean of the population using the approximate
confidence interval 2.
```{r}
lower_bound_ci2 = lambda_hat - qnorm(1-alpha/2)*sqrt(lambda_hat/length(data))
upper_bound_ci2 = lambda_hat + qnorm(1-alpha/2)*sqrt(lambda_hat/length(data))
c(lower_bound_ci2, upper_bound_ci2)
```

1.d Create and save 95% CIs for the mean of the population using the parametric
bootstrap method. ($B$ = `r B`)
```{r}
bootData <- replicate (n=B, expr = rpois (n, lambda_hat))
means<-colMeans(bootData)
c(quantile (means, 0.025), quantile (means, 0.975))
```

1.e Create and save 95% CIs for the mean of the population using the nonparametric
bootstrap method. ($B$ = `r B`)
```{r}
lambda_vec <- rep(NA, B)
for(i in 1:B){
sel <- sample(1:n, n, replace=TRUE)
  bootstrap_x <- data[sel]
  lambda_vec[i] <- mean(bootstrap_x) }
quantile(lambda_vec,c(0.025,0.975))
```

## 2. Repeat the general procedure `N=5000` times

```{r}
N = 5000
```
Create and save a 95% CI for the mean of the population using the approximate
confidence interval 1. Repeat this action `N = ` `r N` times. Sample size `n=` `r n`.

```{r}
means <- c()
lower_bound <- c()
upper_bound <- c()

for (j in 1:N){
  data = rpois (n, lambda)
  means[j] = mean (data) 
  lower_bound[j] = means[j] - qnorm(1-alpha/2)*sqrt(var(data)/length(data))
  upper_bound[j] = means[j] + qnorm(1-alpha/2)*sqrt(var(data)/length(data))  
}
ci_1 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Create and save a 95% CI for the mean of the population using the approximate
confidence interval 2. Repeat this action `N = ` `r N` times. Sample size `n=` `r n`.

```{r}
lower_bound <- c()
upper_bound <- c()
for (j in 1:N) {
  lower_bound[j] = means[j] - qnorm(1-alpha/2)*sqrt(means[j]/length(data))
  upper_bound[j] = means[j] + qnorm(1-alpha/2)*sqrt(means[j]/length(data))
}
ci_2 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Create and save a 95% CI for the mean of the population using parametric bootstrap. Repeat this action `N = ` `r N` times. Sample size `n=` `r n`, 
bootstrap size `B = ` `r B`.

```{r}
means <- c()
lower_bound <- c()
upper_bound <- c()

for (j in 1:N) {
  bootData <- replicate (n=B, expr = rpois (n, lambda_hat))
  means<-colMeans(bootData)
  lower_bound[j] = quantile (means, 0.025)
  upper_bound[j] = quantile (means, 0.975)
}
ci_3 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```


Create and save a 95% CI for the mean of the population using nonparametric bootstrap. Repeat this action `N = ` `r N` times. Sample size `n=` `r n`, 
bootstrap size `B = ` `r B`.

```{r}
 means <- c()
 lower_bound <- c()
 upper_bound <- c()
 
 for (j in 1:N) { 
   lambda_vec <- rep(NA, B)
   for(i in 1:B){
     sel <- sample(1:n, n, replace=TRUE)
     bootstrap_x <- data[sel]
     lambda_vec[i] <- mean(bootstrap_x)  }
   lower_bound[j] <- quantile(lambda_vec, 0.025)
   upper_bound[j] <- quantile(lambda_vec, 0.975)}
 ci_4 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

## 3. Summary about different method execution

Calculate proportion of times each method contains the true value of the mean = 1.
```{r}
ci_1_prop <- nrow (subset (ci_1, ci_1$lower_bound<=lambda & 
                             ci_1$upper_bound >=lambda))/nrow(ci_1)
ci_2_prop <- nrow (subset (ci_2, ci_2$lower_bound<=lambda & 
                             ci_2$upper_bound >=lambda))/nrow(ci_2)
ci_3_prop <- nrow (subset (ci_3, ci_3$lower_bound<=lambda & 
                             ci_3$upper_bound >=lambda))/nrow(ci_3)
ci_4_prop <- nrow (subset (ci_4, ci_4$lower_bound<=lambda & 
                             ci_4$upper_bound >=lambda))/nrow(ci_4)
```

Calculate the average length of the CIs created by the procedure.
```{r}
ci_1_avg <- mean (ci_1$upper_bound - ci_1$lower_bound)
ci_2_avg <- mean (ci_2$upper_bound - ci_2$lower_bound)
ci_3_avg <- mean (ci_3$upper_bound - ci_3$lower_bound)
ci_4_avg <- mean (ci_4$upper_bound - ci_4$lower_bound)

dt <- data.frame (c ("Approximate 1", "Approximate 2", "Parametric Bootstrap", 
                     "Nonparametric Bootstrap"), 
                  c(ci_1_prop, ci_2_prop, ci_3_prop, ci_4_prop), 
                  c (ci_1_avg, ci_2_avg, ci_3_avg, ci_4_avg))
colnames(dt) <- c ("Method", "Prop Containing", "Avg Length")
kable(dt)
```

## 4. Repeat steps above for diffrent sample sizes 
```{r}
n=30
```

Create and save a 95% CI for the mean of the population using the approximate
confidence interval 1. Repeat this action `N = ` `r N` times. Sample size `n=` `r n`.

```{r}
data = rpois (n, lambda)
lambda_hat = mean (data)
approx_var = var (data)

means <- c()
lower_bound <- c()
upper_bound <- c()

for (j in 1:N){
  data = rpois (n, lambda)
  means[j] = mean (data) 
  lower_bound[j] = means[j] - qnorm(1-alpha/2)*sqrt(var(data)/length(data))
  upper_bound[j] = means[j] + qnorm(1-alpha/2)*sqrt(var(data)/length(data))  
}
ci_1 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Create and save a 95% CI for the mean of the population using the approximate
confidence interval 2. Repeat this action `N = ` `r N` times. Sample size `n=` `r n`.

```{r}
lower_bound <- c()
upper_bound <- c()
for (j in 1:N) {
  lower_bound[j] = means[j] - qnorm(1-alpha/2)*sqrt(means[j]/length(data))
  upper_bound[j] = means[j] + qnorm(1-alpha/2)*sqrt(means[j]/length(data))
}
ci_2 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Create and save a 95% CI for the mean of the population using parametric bootstrap. Repeat this action `N = ` `r N` times. Sample size `n=` `r n`, 
bootstrap size `B = ` `r B`.

```{r}
means <- c()
lower_bound <- c()
upper_bound <- c()

for (j in 1:N) {
  bootData <- replicate (n=B, expr = rpois (n, lambda_hat))
  means<-colMeans(bootData)
  lower_bound[j] = quantile (means, 0.025)
  upper_bound[j] = quantile (means, 0.975)
}
ci_3 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Create and save a 95% CI for the mean of the population using nonparametric bootstrap. Repeat this action `N = ` `r N` times. Sample size `n=` `r n`, 
bootstrap size `B = ` `r B`.

```{r}
 means <- c()
 lower_bound <- c()
 upper_bound <- c()
 
 for (j in 1:N) { 
   lambda_vec <- rep(NA, B)
   for(i in 1:B){
     sel <- sample(1:n, n, replace=TRUE)
     bootstrap_x <- data[sel]
     lambda_vec[i] <- mean(bootstrap_x)  }
   lower_bound[j] <- quantile(lambda_vec, 0.025)
   upper_bound[j] <- quantile(lambda_vec, 0.975)}
 ci_4 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)

 ci_1_prop <- nrow (subset (ci_1, ci_1$lower_bound<=lambda & 
                             ci_1$upper_bound >=lambda))/nrow(ci_1)
 ci_2_prop <- nrow (subset (ci_2, ci_2$lower_bound<=lambda & 
                             ci_2$upper_bound >=lambda))/nrow(ci_2)
 ci_3_prop <- nrow (subset (ci_3, ci_3$lower_bound<=lambda & 
                             ci_3$upper_bound >=lambda))/nrow(ci_3)
 ci_4_prop <- nrow (subset (ci_4, ci_4$lower_bound<=lambda & 
                             ci_4$upper_bound >=lambda))/nrow(ci_4)

ci_1_avg <- mean (ci_1$upper_bound - ci_1$lower_bound)
ci_2_avg <- mean (ci_2$upper_bound - ci_2$lower_bound)
ci_3_avg <- mean (ci_3$upper_bound - ci_3$lower_bound)
ci_4_avg <- mean (ci_4$upper_bound - ci_4$lower_bound)

dt <- data.frame (c ("Approximate 1", "Approximate 2", "Parametric Bootstrap", 
                     "Nonparametric Bootstrap"), 
                  c(ci_1_prop, ci_2_prop, ci_3_prop, ci_4_prop), 
                  c (ci_1_avg, ci_2_avg, ci_3_avg, ci_4_avg))
colnames(dt) <- c ("Method", "Prop Containing", "Avg Length")
kable(dt)
```

```{r}
n=200
```

Repeat steps above for sample size `n`=`r n`

```{r}
#data <- c(rep(0, 109), rep(1,65), rep(2,22), rep(3,3), rep(4,1))
data = rpois (n, lambda)

```

Creating and saving 95% CI for mean using the approximate confidence interval 1 approach:

```{r}
lambda_hat = mean (data)

means <- c()
lower_bound <- c()
upper_bound <- c()

for (j in 1:N){
  data = rpois (n, lambda_hat)
  means[j] = mean (data) 
  lower_bound[j] = means[j] - qnorm(1-alpha/2)*sqrt(var(data)/length(data))
  upper_bound[j] = means[j] + qnorm(1-alpha/2)*sqrt(var(data)/length(data))  
}
ci_1 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Creating and saving 95% CI for mean using the approximate confidence interval 2 approach:
  
```{r} 
lower_bound <- c()
upper_bound <- c()
for (j in 1:N) {
  lower_bound[j] = means[j] - qnorm(1-alpha/2)*sqrt(means[j]/length(data))
  upper_bound[j] = means[j] + qnorm(1-alpha/2)*sqrt(means[j]/length(data))
}
ci_2 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Creating and saving 95% CI for mean using the parametric bootstrap approach:

```{r} 
means <- c()
lower_bound <- c()
upper_bound <- c()

for (j in 1:N) {
  bootData <- replicate (n=B, expr = rpois (n, lambda_hat))
  means<-colMeans(bootData)
  lower_bound[j] = quantile (means, 0.025)
  upper_bound[j] = quantile (means, 0.975)
  
}
ci_3 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Creating and saving 95% CI for mean using the non-parametric bootstrap approach:

```{r}
 means <- c()
 lower_bound <- c()
 upper_bound <- c()
 
 for (j in 1:N) { 
   lambda_vec <- rep(NA, B)
   for(i in 1:B){
     sel <- sample(1:n, n, replace=TRUE)
     bootstrap_x <- data[sel]
     lambda_vec[i] <- mean(bootstrap_x)  }
   lower_bound[j] <- quantile(lambda_vec, 0.025)
   upper_bound[j] <- quantile(lambda_vec, 0.975)}
 ci_4 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)

 
ci_1_prop <- nrow (subset (ci_1, ci_1$lower_bound<=lambda & 
                             ci_1$upper_bound>=lambda))/nrow(ci_1)
ci_2_prop <- nrow (subset (ci_2, ci_2$lower_bound<=lambda & 
                             ci_2$upper_bound>=lambda))/nrow(ci_2)
ci_3_prop <- nrow (subset (ci_3, ci_3$lower_bound<=lambda & 
                             ci_3$upper_bound>=lambda))/nrow(ci_3)
ci_4_prop <- nrow (subset (ci_4, ci_4$lower_bound<=lambda & 
                             ci_4$upper_bound>=lambda))/nrow(ci_4)

ci_1_avg <- mean (ci_1$upper_bound - ci_1$lower_bound)
ci_2_avg <- mean (ci_2$upper_bound - ci_2$lower_bound)
ci_3_avg <- mean (ci_3$upper_bound - ci_3$lower_bound)
ci_4_avg <- mean (ci_4$upper_bound - ci_4$lower_bound)

dt <- data.frame (c ("Approximate 1", "Approximate 2", "Parametric Bootstrap", 
                     "Nonparametric Bootstrap"), 
                  c(ci_1_prop, ci_2_prop, ci_3_prop, ci_4_prop), 
                  c (ci_1_avg, ci_2_avg, ci_3_avg, ci_4_avg))
colnames(dt) <- c ("Method", "Prop Containing", "Avg Length")
kable(dt)
```



## 5. Advantages and disadvantages of different types of interval 

1. Confidence interval based on Normal distribution with true population variance.
   Difficult to use in real life because usually we do not know population variance. 

2. Confidence interval based on Normal distribution with estimated variance.
   Relies on CLT and requires sample size to be large. For not large samples could not work correctly.  
   Does not require normality from the original data. 

3. Confidence Interval based on Parametric bootsrap
   Requires assumption about population distribution that could be wrong. 
   If you don have large enough sample and know approximately population distribution then Parametric bootstarp will work better that Nonparametric.

4. Confidence Interval based on Nonparametric bootsrtap
   Works very well when sample size is large enough and we do not population didtribution.     

## 6. Apply the 4 different methods to the horse-kick death data and report the 95% confidence intervals obtained by each method.

Generating horse-kick death data, `n=` 'r n`

```{r}
data <- c(rep(0, 109), rep(1,65), rep(2,22), rep(3,3), rep(4,1))
```

Creating and saving 95% CI for mean using the approximate confidence interval 1 approach:

```{r}
lambda_hat = mean (data)

means <- c()
lower_bound <- c()
upper_bound <- c()


  data = rpois (n, lambda_hat)
  means = mean (data) 
  lower_bound = means - qnorm(1-alpha/2)*sqrt(var(data)/length(data))
  upper_bound = means + qnorm(1-alpha/2)*sqrt(var(data)/length(data))  

ci_1 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Creating and saving 95% CI for mean using the approximate confidence interval 2 approach:
  
```{r} 
lower_bound <- c()
upper_bound <- c()

  lower_bound = means - qnorm(1-alpha/2)*sqrt(means/length(data))
  upper_bound = means + qnorm(1-alpha/2)*sqrt(means/length(data))

ci_2 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)

```

Creating and saving 95% CI for mean using the parametric bootstrap approach:

```{r} 
means <- c()
lower_bound <- c()
upper_bound <- c()

  bootData <- replicate (n=B, expr = rpois (n, lambda_hat))
  means<-colMeans(bootData)
  lower_bound = quantile (means, 0.025)
  upper_bound = quantile (means, 0.975)
  
ci_3 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
```

Creating and saving 95% CI for mean using the non-parametric bootstrap approach:

```{r}
 means <- c()
 lower_bound <- c()
 upper_bound <- c()
 
   lambda_vec <- rep(NA, B)
   for(i in 1:B){
     sel <- sample(1:n, n, replace=TRUE)
     bootstrap_x <- data[sel]
     lambda_vec[i] <- mean(bootstrap_x)  } 
   lower_bound <- quantile(lambda_vec, 0.025)
   upper_bound <- quantile(lambda_vec, 0.975)  #}
ci_4 <- data.frame ("lower_bound" = lower_bound, "upper_bound" = upper_bound)
 
ci_1_prop <- nrow (subset (ci_1, ci_1$lower_bound<=lambda_hat & 
                             ci_1$upper_bound>=lambda_hat))/nrow(ci_1)
ci_2_prop <- nrow (subset (ci_2, ci_2$lower_bound<=lambda_hat & 
                             ci_2$upper_bound>=lambda_hat))/nrow(ci_2)
ci_3_prop <- nrow (subset (ci_3, ci_3$lower_bound<=lambda_hat & 
                             ci_3$upper_bound>=lambda_hat))/nrow(ci_3)
ci_4_prop <- nrow (subset (ci_4, ci_4$lower_bound<=lambda_hat & 
                             ci_4$upper_bound>=lambda_hat))/nrow(ci_4)

ci_1_avg <- mean (ci_1$upper_bound - ci_1$lower_bound)
ci_2_avg <- mean (ci_2$upper_bound - ci_2$lower_bound)
ci_3_avg <- mean (ci_3$upper_bound - ci_3$lower_bound)
ci_4_avg <- mean (ci_4$upper_bound - ci_4$lower_bound)

#dt <- data.frame (c ("Approximate 1", "Approximate 2", "Parametric Bootstrap", 
#                     "Nonparametric Bootstrap"), 
#                  c(ci_1_prop, ci_2_prop, ci_3_prop, ci_4_prop), 
#                  c (ci_1_avg, ci_2_avg, ci_3_avg, ci_4_avg))

#colnames(dt) <- c ("Method", "Prop Containing", "Avg Length")
#kable(dt)
```

95%  Confidence Interval depending on method

```{r}
dci <- data.frame (  c("CI 1", "CI 2", "Parametric Bootsrap", "Nonparametric bootstrap"),
                     c( ci_1$lower_bound, ci_2$lower_bound,ci_3$lower_bound, ci_4$lower_bound ), 
                     c(ci_1$upper_bound, ci_2$upper_bound, ci_3$upper_bound, ci_4$upper_bound)  )

colnames (dci) <- c ("Method", "Lower Bound", "Upper Bound")
kable(dci)
```

## Conclusion